(window.webpackJsonp=window.webpackJsonp||[]).push([[290],{817:function(e,t,a){"use strict";a.r(t);var s=a(21),n=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"webidl-type-conversions-on-javascript-values"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webidl-type-conversions-on-javascript-values"}},[e._v("#")]),e._v(" WebIDL Type Conversions on JavaScript Values")]),e._v(" "),t("p",[e._v("This package implements, in JavaScript, the algorithms to convert a given JavaScript value according to a given "),t("a",{attrs:{href:"http://heycam.github.io/webidl/",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebIDL"),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"http://heycam.github.io/webidl/#idl-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("type"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[e._v("The goal is that you should be able to write code like")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" conversions "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("require")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"webidl-conversions"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("doStuff")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" y")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    x "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" conversions"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"boolean"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    y "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" conversions"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"unsigned long"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// actual algorithm code here")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("p",[e._v("and your function "),t("code",[e._v("doStuff")]),e._v(" will behave the same as a WebIDL operation declared as")]),e._v(" "),t("div",{staticClass:"language-webidl extra-class"},[t("pre",{pre:!0,attrs:{class:"language-webidl"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")])]),e._v(" doStuff"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("boolean")])]),e._v(" x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")])]),e._v(" y"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("h2",{attrs:{id:"api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[e._v("#")]),e._v(" API")]),e._v(" "),t("p",[e._v("This package's main module's default export is an object with a variety of methods, each corresponding to a different WebIDL type. Each method, when invoked on a JavaScript value, will give back the new JavaScript value that results after passing through the WebIDL conversion rules. (See below for more details on what that means.) Alternately, the method could throw an error, if the WebIDL algorithm is specified to do so: for example "),t("code",[e._v('conversions["float"](NaN)')]),e._v(" "),t("a",{attrs:{href:"http://heycam.github.io/webidl/#es-float",target:"_blank",rel:"noopener noreferrer"}},[e._v("will throw a "),t("code",[e._v("TypeError")]),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"status"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#status"}},[e._v("#")]),e._v(" Status")]),e._v(" "),t("p",[e._v("All of the numeric types are implemented (float being implemented as double) and some others are as well - check the source for all of them. This list will grow over time in service of the "),t("a",{attrs:{href:"https://github.com/dglazkov/html-as-custom-elements",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTML as Custom Elements"),t("OutboundLink")],1),e._v(" project, but in the meantime, pull requests welcome!")]),e._v(" "),t("p",[e._v("I'm not sure yet what the strategy will be for modifiers, e.g. "),t("a",{attrs:{href:"http://heycam.github.io/webidl/#Clamp",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("[Clamp]")]),t("OutboundLink")],1),e._v(". Maybe something like "),t("code",[e._v('conversions["unsigned long"](x, { clamp: true })')]),e._v("? We'll see.")]),e._v(" "),t("p",[e._v('We might also want to extend the API to give better error messages, e.g. "Argument 1 of HTMLMediaElement.fastSeek is not a finite floating-point value" instead of "Argument is not a finite floating-point value." This would require passing in more information to the conversion functions than we currently do.')]),e._v(" "),t("h2",{attrs:{id:"background"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),t("p",[e._v("What's actually going on here, conceptually, is pretty weird. Let's try to explain.")]),e._v(" "),t("p",[e._v("WebIDL, as part of its madness-inducing design, has its own type system. When people write algorithms in web platform specs, they usually operate on WebIDL values, i.e. instances of WebIDL types. For example, if they were specifying the algorithm for our "),t("code",[e._v("doStuff")]),e._v(" operation above, they would treat "),t("code",[e._v("x")]),e._v(" as a WebIDL value of "),t("a",{attrs:{href:"http://heycam.github.io/webidl/#idl-boolean",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebIDL type "),t("code",[e._v("boolean")]),t("OutboundLink")],1),e._v(". Crucially, they would "),t("em",[e._v("not")]),e._v(" treat "),t("code",[e._v("x")]),e._v(" as a JavaScript variable whose value is either the JavaScript "),t("code",[e._v("true")]),e._v(" or "),t("code",[e._v("false")]),e._v(". They're instead working in a different type system altogether, with its own rules.")]),e._v(" "),t("p",[e._v("Separately from its type system, WebIDL defines a "),t("a",{attrs:{href:"http://heycam.github.io/webidl/#ecmascript-binding",target:"_blank",rel:"noopener noreferrer"}},[e._v('"binding"'),t("OutboundLink")],1),e._v(" of the type system into JavaScript. This contains rules like: when you pass a JavaScript value to the JavaScript method that manifests a given WebIDL operation, how does that get converted into a WebIDL value? For example, a JavaScript "),t("code",[e._v("true")]),e._v(" passed in the position of a WebIDL "),t("code",[e._v("boolean")]),e._v(" argument becomes a WebIDL "),t("code",[e._v("true")]),e._v(". But, a JavaScript "),t("code",[e._v("true")]),e._v(" passed in the position of a "),t("a",{attrs:{href:"http://heycam.github.io/webidl/#idl-unsigned-long",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebIDL "),t("code",[e._v("unsigned long")]),t("OutboundLink")],1),e._v(" becomes a WebIDL "),t("code",[e._v("1")]),e._v(". And so on.")]),e._v(" "),t("p",[e._v("Finally, we have the actual implementation code. This is usually C++, although these days "),t("a",{attrs:{href:"https://github.com/servo/servo",target:"_blank",rel:"noopener noreferrer"}},[e._v("some smart people are using Rust"),t("OutboundLink")],1),e._v(". The implementation, of course, has its own type system. So when they implement the WebIDL algorithms, they don't actually use WebIDL values, since those aren't \"real\" outside of specs. Instead, implementations apply the WebIDL binding rules in such a way as to convert incoming JavaScript values into C++ values. For example, if code in the browser called "),t("code",[e._v("doStuff(true, true)")]),e._v(", then the implementation code would eventually receive a C++ "),t("code",[e._v("bool")]),e._v(" containing "),t("code",[e._v("true")]),e._v(" and a C++ "),t("code",[e._v("uint32_t")]),e._v(" containing "),t("code",[e._v("1")]),e._v(".")]),e._v(" "),t("p",[e._v("The upside of all this is that implementations can abstract all the conversion logic away, letting WebIDL handle it, and focus on implementing the relevant methods in C++ with values of the correct type already provided. That is payoff of WebIDL, in a nutshell.")]),e._v(" "),t("p",[e._v("And getting to that payoff is the goal of "),t("em",[e._v("this")]),e._v(" project—but for JavaScript implementations, instead of C++ ones. That is, this library is designed to make it easier for JavaScript developers to write functions that behave like a given WebIDL operation. So conceptually, the conversion pipeline, which in its general form is JavaScript values ↦ WebIDL values ↦ implementation-language values, in this case becomes JavaScript values ↦ WebIDL values ↦ JavaScript values. And that intermediate step is where all the logic is performed: a JavaScript "),t("code",[e._v("true")]),e._v(" becomes a WebIDL "),t("code",[e._v("1")]),e._v(" in an unsigned long context, which then becomes a JavaScript "),t("code",[e._v("1")]),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"don-t-use-this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#don-t-use-this"}},[e._v("#")]),e._v(" Don't Use This")]),e._v(" "),t("p",[e._v("Seriously, why would you ever use this? You really shouldn't. WebIDL is … not great, and you shouldn't be emulating its semantics. If you're looking for a generic argument-processing library, you should find one with better rules than those from WebIDL. In general, your JavaScript should not be trying to become more like WebIDL; if anything, we should fix WebIDL to make it more like JavaScript.")]),e._v(" "),t("p",[e._v("The "),t("em",[e._v("only")]),e._v(" people who should use this are those trying to create faithful implementations (or polyfills) of web platform interfaces defined in WebIDL.")])])}),[],!1,null,null,null);t.default=n.exports}}]);