(window.webpackJsonp=window.webpackJsonp||[]).push([[241],{767:function(e,t,r){"use strict";r.r(t);var a=r(21),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[t("a",{attrs:{href:"https://travis-ci.org/isaacs/rimraf",target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:"https://travis-ci.org/isaacs/rimraf.svg?branch=master",alt:"Build Status"}}),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://david-dm.org/isaacs/rimraf",target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:"https://david-dm.org/isaacs/rimraf.svg",alt:"Dependency Status"}}),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://david-dm.org/isaacs/rimraf#info=devDependencies",target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:"https://david-dm.org/isaacs/rimraf/dev-status.svg",alt:"devDependency Status"}}),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The "),t("a",{attrs:{href:"http://en.wikipedia.org/wiki/Rm_(Unix)",target:"_blank",rel:"noopener noreferrer"}},[e._v("UNIX command"),t("OutboundLink")],1),e._v(" "),t("code",[e._v("rm -rf")]),e._v(" for node.")]),e._v(" "),t("p",[e._v("Install with "),t("code",[e._v("npm install rimraf")]),e._v(", or just drop rimraf.js somewhere.")]),e._v(" "),t("h2",{attrs:{id:"api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[e._v("#")]),e._v(" API")]),e._v(" "),t("p",[t("code",[e._v("rimraf(f, [opts], callback)")])]),e._v(" "),t("p",[e._v("The first parameter will be interpreted as a globbing pattern for files. If you\nwant to disable globbing you can do so with "),t("code",[e._v("opts.disableGlob")]),e._v(" (defaults to\n"),t("code",[e._v("false")]),e._v("). This might be handy, for instance, if you have filenames that contain\nglobbing wildcard characters.")]),e._v(" "),t("p",[e._v("The callback will be called with an error if there is one.  Certain\nerrors are handled for you:")]),e._v(" "),t("ul",[t("li",[e._v("Windows: "),t("code",[e._v("EBUSY")]),e._v(" and "),t("code",[e._v("ENOTEMPTY")]),e._v(" - rimraf will back off a maximum of\n"),t("code",[e._v("opts.maxBusyTries")]),e._v(" times before giving up, adding 100ms of wait\nbetween each attempt.  The default "),t("code",[e._v("maxBusyTries")]),e._v(" is 3.")]),e._v(" "),t("li",[t("code",[e._v("ENOENT")]),e._v(" - If the file doesn't exist, rimraf will return\nsuccessfully, since your desired outcome is already the case.")]),e._v(" "),t("li",[t("code",[e._v("EMFILE")]),e._v(" - Since "),t("code",[e._v("readdir")]),e._v(" requires opening a file descriptor, it's\npossible to hit "),t("code",[e._v("EMFILE")]),e._v(" if too many file descriptors are in use.\nIn the sync case, there's nothing to be done for this.  But in the\nasync case, rimraf will gradually back off with timeouts up to\n"),t("code",[e._v("opts.emfileWait")]),e._v(" ms, which defaults to 1000.")])]),e._v(" "),t("h2",{attrs:{id:"options"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#options"}},[e._v("#")]),e._v(" options")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("unlink, chmod, stat, lstat, rmdir, readdir,\nunlinkSync, chmodSync, statSync, lstatSync, rmdirSync, readdirSync")]),e._v(" "),t("p",[e._v("In order to use a custom file system library, you can override\nspecific fs functions on the options object.")]),e._v(" "),t("p",[e._v("If any of these functions are present on the options object, then\nthe supplied function will be used instead of the default fs\nmethod.")]),e._v(" "),t("p",[e._v("Sync methods are only relevant for "),t("code",[e._v("rimraf.sync()")]),e._v(", of course.")]),e._v(" "),t("p",[e._v("For example:")]),e._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" myCustomFS "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("require")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'some-custom-fs'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\n"),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("rimraf")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'some-thing'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" myCustomFS"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" callback"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])])]),e._v(" "),t("li",[t("p",[e._v("maxBusyTries")]),e._v(" "),t("p",[e._v("If an "),t("code",[e._v("EBUSY")]),e._v(", "),t("code",[e._v("ENOTEMPTY")]),e._v(", or "),t("code",[e._v("EPERM")]),e._v(" error code is encountered\non Windows systems, then rimraf will retry with a linear backoff\nwait of 100ms longer on each try.  The default maxBusyTries is 3.")]),e._v(" "),t("p",[e._v("Only relevant for async usage.")])]),e._v(" "),t("li",[t("p",[e._v("emfileWait")]),e._v(" "),t("p",[e._v("If an "),t("code",[e._v("EMFILE")]),e._v(" error is encountered, then rimraf will retry\nrepeatedly with a linear backoff of 1ms longer on each try, until\nthe timeout counter hits this max.  The default limit is 1000.")]),e._v(" "),t("p",[e._v("If you repeatedly encounter "),t("code",[e._v("EMFILE")]),e._v(" errors, then consider using\n"),t("a",{attrs:{href:"http://npm.im/graceful-fs",target:"_blank",rel:"noopener noreferrer"}},[e._v("graceful-fs"),t("OutboundLink")],1),e._v(" in your program.")]),e._v(" "),t("p",[e._v("Only relevant for async usage.")])]),e._v(" "),t("li",[t("p",[e._v("glob")]),e._v(" "),t("p",[e._v("Set to "),t("code",[e._v("false")]),e._v(" to disable "),t("a",{attrs:{href:"http://npm.im/glob",target:"_blank",rel:"noopener noreferrer"}},[e._v("glob"),t("OutboundLink")],1),e._v(" pattern\nmatching.")]),e._v(" "),t("p",[e._v("Set to an object to pass options to the glob module.  The default\nglob options are "),t("code",[e._v("{ nosort: true, silent: true }")]),e._v(".")]),e._v(" "),t("p",[e._v("Glob version 6 is used in this module.")]),e._v(" "),t("p",[e._v("Relevant for both sync and async usage.")])]),e._v(" "),t("li",[t("p",[e._v("disableGlob")]),e._v(" "),t("p",[e._v("Set to any non-falsey value to disable globbing entirely.\n(Equivalent to setting "),t("code",[e._v("glob: false")]),e._v(".)")])])]),e._v(" "),t("h2",{attrs:{id:"rimraf-sync"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rimraf-sync"}},[e._v("#")]),e._v(" rimraf.sync")]),e._v(" "),t("p",[e._v("It can remove stuff synchronously, too.  But that's not so good.  Use\nthe async API.  It's better.")]),e._v(" "),t("h2",{attrs:{id:"cli"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cli"}},[e._v("#")]),e._v(" CLI")]),e._v(" "),t("p",[e._v("If installed with "),t("code",[e._v("npm install rimraf -g")]),e._v(" it can be used as a global\ncommand "),t("code",[e._v("rimraf <path> [<path> ...]")]),e._v(" which is useful for cross platform support.")]),e._v(" "),t("h2",{attrs:{id:"mkdirp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mkdirp"}},[e._v("#")]),e._v(" mkdirp")]),e._v(" "),t("p",[e._v("If you need to create a directory recursively, check out\n"),t("a",{attrs:{href:"https://github.com/substack/node-mkdirp",target:"_blank",rel:"noopener noreferrer"}},[e._v("mkdirp"),t("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);