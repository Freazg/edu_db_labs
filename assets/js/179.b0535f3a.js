(window.webpackJsonp=window.webpackJsonp||[]).push([[179],{708:function(t,a,e){"use strict";e.r(a);var s=e(21),n=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"minimatch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#minimatch"}},[t._v("#")]),t._v(" minimatch")]),t._v(" "),a("p",[t._v("A minimal matching utility.")]),t._v(" "),a("p",[a("a",{attrs:{href:"http://travis-ci.org/isaacs/minimatch",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"https://travis-ci.org/isaacs/minimatch.svg?branch=master",alt:"Build Status"}}),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("This is the matching library used internally by npm.")]),t._v(" "),a("p",[t._v("It works by converting glob expressions into JavaScript "),a("code",[t._v("RegExp")]),t._v("\nobjects.")]),t._v(" "),a("h2",{attrs:{id:"usage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usage"}},[t._v("#")]),t._v(" Usage")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" minimatch "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"minimatch"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("minimatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bar.foo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*.foo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true!")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("minimatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bar.foo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*.bar"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false!")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("minimatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bar.foo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*.+(bar|foo)"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("debug")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true, and noisy!")]),t._v("\n")])])]),a("h2",{attrs:{id:"features"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#features"}},[t._v("#")]),t._v(" Features")]),t._v(" "),a("p",[t._v("Supports these glob features:")]),t._v(" "),a("ul",[a("li",[t._v("Brace Expansion")]),t._v(" "),a("li",[t._v("Extended glob matching")]),t._v(" "),a("li",[t._v('"Globstar" '),a("code",[t._v("**")]),t._v(" matching")])]),t._v(" "),a("p",[t._v("See:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("man sh")])]),t._v(" "),a("li",[a("code",[t._v("man bash")])]),t._v(" "),a("li",[a("code",[t._v("man 3 fnmatch")])]),t._v(" "),a("li",[a("code",[t._v("man 5 gitignore")])])]),t._v(" "),a("h2",{attrs:{id:"minimatch-class"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#minimatch-class"}},[t._v("#")]),t._v(" Minimatch Class")]),t._v(" "),a("p",[t._v("Create a minimatch object by instantiating the "),a("code",[t._v("minimatch.Minimatch")]),t._v(" class.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" Minimatch "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"minimatch"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Minimatch\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" mm "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Minimatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pattern"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h3",{attrs:{id:"properties"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#properties"}},[t._v("#")]),t._v(" Properties")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("pattern")]),t._v(" The original pattern the minimatch object represents.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("options")]),t._v(" The options supplied to the constructor.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("set")]),t._v(" A 2-dimensional array of regexp or string expressions.\nEach row in the\narray corresponds to a brace-expanded pattern.  Each item in the row\ncorresponds to a single path-part.  For example, the pattern\n"),a("code",[t._v("{a,b/c}/d")]),t._v(" would expand to a set of patterns like:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("  [ [ a, d ]\n  , [ b, c, d ] ]\n")])])]),a("p",[t._v("If a portion of the pattern doesn't have any \"magic\" in it\n(that is, it's something like "),a("code",[t._v('"foo"')]),t._v(" rather than "),a("code",[t._v("fo*o?")]),t._v("), then it\nwill be left as a string rather than converted to a regular\nexpression.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("regexp")]),t._v(" Created by the "),a("code",[t._v("makeRe")]),t._v(" method.  A single regular expression\nexpressing the entire pattern.  This is useful in cases where you wish\nto use the pattern somewhat like "),a("code",[t._v("fnmatch(3)")]),t._v(" with "),a("code",[t._v("FNM_PATH")]),t._v(" enabled.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("negate")]),t._v(" True if the pattern is negated.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("comment")]),t._v(" True if the pattern is a comment.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("empty")]),t._v(" True if the pattern is "),a("code",[t._v('""')]),t._v(".")])])]),t._v(" "),a("h3",{attrs:{id:"methods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#methods"}},[t._v("#")]),t._v(" Methods")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("makeRe")]),t._v(" Generate the "),a("code",[t._v("regexp")]),t._v(" member if necessary, and return it.\nWill return "),a("code",[t._v("false")]),t._v(" if the pattern is invalid.")]),t._v(" "),a("li",[a("code",[t._v("match(fname)")]),t._v(" Return true if the filename matches the pattern, or\nfalse otherwise.")]),t._v(" "),a("li",[a("code",[t._v("matchOne(fileArray, patternArray, partial)")]),t._v(" Take a "),a("code",[t._v("/")]),t._v("-split\nfilename, and match it against a single row in the "),a("code",[t._v("regExpSet")]),t._v(".  This\nmethod is mainly for internal use, but is exposed so that it can be\nused by a glob-walker that needs to avoid excessive filesystem calls.")])]),t._v(" "),a("p",[t._v("All other methods are internal, and will be called as necessary.")]),t._v(" "),a("h3",{attrs:{id:"minimatch-path-pattern-options"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#minimatch-path-pattern-options"}},[t._v("#")]),t._v(" minimatch(path, pattern, options)")]),t._v(" "),a("p",[t._v("Main export.  Tests a path against the pattern using the options.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" isJS "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("minimatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("file"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*.js"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("matchBase")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h3",{attrs:{id:"minimatch-filter-pattern-options"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#minimatch-filter-pattern-options"}},[t._v("#")]),t._v(" minimatch.filter(pattern, options)")]),t._v(" "),a("p",[t._v("Returns a function that tests its\nsupplied argument, suitable for use with "),a("code",[t._v("Array.filter")]),t._v(".  Example:")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" javascripts "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fileList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("filter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("minimatch"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("filter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*.js"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("matchBase")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h3",{attrs:{id:"minimatch-match-list-pattern-options"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#minimatch-match-list-pattern-options"}},[t._v("#")]),t._v(" minimatch.match(list, pattern, options)")]),t._v(" "),a("p",[t._v("Match against the list of\nfiles, in the style of fnmatch or glob.  If nothing is matched, and\noptions.nonull is set, then return a list containing the pattern itself.")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" javascripts "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" minimatch"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fileList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*.js"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("matchBase")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h3",{attrs:{id:"minimatch-makere-pattern-options"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#minimatch-makere-pattern-options"}},[t._v("#")]),t._v(" minimatch.makeRe(pattern, options)")]),t._v(" "),a("p",[t._v("Make a regular expression object from the pattern.")]),t._v(" "),a("h2",{attrs:{id:"options"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#options"}},[t._v("#")]),t._v(" Options")]),t._v(" "),a("p",[t._v("All options are "),a("code",[t._v("false")]),t._v(" by default.")]),t._v(" "),a("h3",{attrs:{id:"debug"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#debug"}},[t._v("#")]),t._v(" debug")]),t._v(" "),a("p",[t._v("Dump a ton of stuff to stderr.")]),t._v(" "),a("h3",{attrs:{id:"nobrace"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nobrace"}},[t._v("#")]),t._v(" nobrace")]),t._v(" "),a("p",[t._v("Do not expand "),a("code",[t._v("{a,b}")]),t._v(" and "),a("code",[t._v("{1..3}")]),t._v(" brace sets.")]),t._v(" "),a("h3",{attrs:{id:"noglobstar"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#noglobstar"}},[t._v("#")]),t._v(" noglobstar")]),t._v(" "),a("p",[t._v("Disable "),a("code",[t._v("**")]),t._v(" matching against multiple folder names.")]),t._v(" "),a("h3",{attrs:{id:"dot"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dot"}},[t._v("#")]),t._v(" dot")]),t._v(" "),a("p",[t._v("Allow patterns to match filenames starting with a period, even if\nthe pattern does not explicitly have a period in that spot.")]),t._v(" "),a("p",[t._v("Note that by default, "),a("code",[t._v("a/**/b")]),t._v(" will "),a("strong",[t._v("not")]),t._v(" match "),a("code",[t._v("a/.d/b")]),t._v(", unless "),a("code",[t._v("dot")]),t._v("\nis set.")]),t._v(" "),a("h3",{attrs:{id:"noext"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#noext"}},[t._v("#")]),t._v(" noext")]),t._v(" "),a("p",[t._v('Disable "extglob" style patterns like '),a("code",[t._v("+(a|b)")]),t._v(".")]),t._v(" "),a("h3",{attrs:{id:"nocase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nocase"}},[t._v("#")]),t._v(" nocase")]),t._v(" "),a("p",[t._v("Perform a case-insensitive match.")]),t._v(" "),a("h3",{attrs:{id:"nonull"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nonull"}},[t._v("#")]),t._v(" nonull")]),t._v(" "),a("p",[t._v("When a match is not found by "),a("code",[t._v("minimatch.match")]),t._v(", return a list containing\nthe pattern itself if this option is set.  When not set, an empty list\nis returned if there are no matches.")]),t._v(" "),a("h3",{attrs:{id:"matchbase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#matchbase"}},[t._v("#")]),t._v(" matchBase")]),t._v(" "),a("p",[t._v("If set, then patterns without slashes will be matched\nagainst the basename of the path if it contains slashes.  For example,\n"),a("code",[t._v("a?b")]),t._v(" would match the path "),a("code",[t._v("/xyz/123/acb")]),t._v(", but not "),a("code",[t._v("/xyz/acb/123")]),t._v(".")]),t._v(" "),a("h3",{attrs:{id:"nocomment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nocomment"}},[t._v("#")]),t._v(" nocomment")]),t._v(" "),a("p",[t._v("Suppress the behavior of treating "),a("code",[t._v("#")]),t._v(" at the start of a pattern as a\ncomment.")]),t._v(" "),a("h3",{attrs:{id:"nonegate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nonegate"}},[t._v("#")]),t._v(" nonegate")]),t._v(" "),a("p",[t._v("Suppress the behavior of treating a leading "),a("code",[t._v("!")]),t._v(" character as negation.")]),t._v(" "),a("h3",{attrs:{id:"flipnegate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flipnegate"}},[t._v("#")]),t._v(" flipNegate")]),t._v(" "),a("p",[t._v("Returns from negate expressions the same as if they were not negated.\n(Ie, true on a hit, false on a miss.)")]),t._v(" "),a("h3",{attrs:{id:"partial"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#partial"}},[t._v("#")]),t._v(" partial")]),t._v(" "),a("p",[t._v("Compare a partial path to a pattern.  As long as the parts of the path that\nare present are not contradicted by the pattern, it will be treated as a\nmatch.  This is useful in applications where you're walking through a\nfolder structure, and don't yet have the full path, but want to ensure that\nyou do not walk down paths that can never be a match.")]),t._v(" "),a("p",[t._v("For example,")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("minimatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/a/b'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/a/*/c/d'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("partial")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true, might be /a/b/c/d")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("minimatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/a/b'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/**/d'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("partial")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true, might be /a/b/.../d")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("minimatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/x/y/z'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/a/**/z'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("partial")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false, because x !== a")]),t._v("\n")])])]),a("h3",{attrs:{id:"allowwindowsescape"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#allowwindowsescape"}},[t._v("#")]),t._v(" allowWindowsEscape")]),t._v(" "),a("p",[t._v("Windows path separator "),a("code",[t._v("\\")]),t._v(" is by default converted to "),a("code",[t._v("/")]),t._v(", which\nprohibits the usage of "),a("code",[t._v("\\")]),t._v(" as a escape character. This flag skips that\nbehavior and allows using the escape character.")]),t._v(" "),a("h2",{attrs:{id:"comparisons-to-other-fnmatch-glob-implementations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#comparisons-to-other-fnmatch-glob-implementations"}},[t._v("#")]),t._v(" Comparisons to other fnmatch/glob implementations")]),t._v(" "),a("p",[t._v("While strict compliance with the existing standards is a worthwhile\ngoal, some discrepancies exist between minimatch and other\nimplementations, and are intentional.")]),t._v(" "),a("p",[t._v("If the pattern starts with a "),a("code",[t._v("!")]),t._v(" character, then it is negated.  Set the\n"),a("code",[t._v("nonegate")]),t._v(" flag to suppress this behavior, and treat leading "),a("code",[t._v("!")]),t._v("\ncharacters normally.  This is perhaps relevant if you wish to start the\npattern with a negative extglob pattern like "),a("code",[t._v("!(a|B)")]),t._v(".  Multiple "),a("code",[t._v("!")]),t._v("\ncharacters at the start of a pattern will negate the pattern multiple\ntimes.")]),t._v(" "),a("p",[t._v("If a pattern starts with "),a("code",[t._v("#")]),t._v(", then it is treated as a comment, and\nwill not match anything.  Use "),a("code",[t._v("\\#")]),t._v(" to match a literal "),a("code",[t._v("#")]),t._v(" at the\nstart of a line, or set the "),a("code",[t._v("nocomment")]),t._v(" flag to suppress this behavior.")]),t._v(" "),a("p",[t._v("The double-star character "),a("code",[t._v("**")]),t._v(" is supported by default, unless the\n"),a("code",[t._v("noglobstar")]),t._v(" flag is set.  This is supported in the manner of bsdglob\nand bash 4.1, where "),a("code",[t._v("**")]),t._v(" only has special significance if it is the only\nthing in a path part.  That is, "),a("code",[t._v("a/**/b")]),t._v(" will match "),a("code",[t._v("a/x/y/b")]),t._v(", but\n"),a("code",[t._v("a/**b")]),t._v(" will not.")]),t._v(" "),a("p",[t._v("If an escaped pattern has no matches, and the "),a("code",[t._v("nonull")]),t._v(" flag is set,\nthen minimatch.match returns the pattern as-provided, rather than\ninterpreting the character escapes.  For example,\n"),a("code",[t._v('minimatch.match([], "\\\\*a\\\\?")')]),t._v(" will return "),a("code",[t._v('"\\\\*a\\\\?"')]),t._v(" rather than\n"),a("code",[t._v('"*a?"')]),t._v(".  This is akin to setting the "),a("code",[t._v("nullglob")]),t._v(" option in bash, except\nthat it does not resolve escaped pattern characters.")]),t._v(" "),a("p",[t._v("If brace expansion is not disabled, then it is performed before any\nother interpretation of the glob pattern.  Thus, a pattern like\n"),a("code",[t._v("+(a|{b),c)}")]),t._v(", which would not be valid in bash or zsh, is expanded\n"),a("strong",[t._v("first")]),t._v(" into the set of "),a("code",[t._v("+(a|b)")]),t._v(" and "),a("code",[t._v("+(a|c)")]),t._v(", and those patterns are\nchecked for validity.  Since those two are valid, matching proceeds.")])])}),[],!1,null,null,null);a.default=n.exports}}]);